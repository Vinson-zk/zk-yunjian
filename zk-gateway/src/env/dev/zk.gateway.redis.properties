
# redis服务器地址
zk.gateway.cache.redis.host=127.0.0.1
# redis服务器连接端口
zk.gateway.cache.redis.port=6379 
# redis数据库索引（默认为0）
zk.gateway.cache.redis.database=0 
# redis服务器连接密码（默认为空）
zk.gateway.cache.redis.password=root
# 连接超时时间（毫秒）
zk.gateway.cache.redis.timeout=6000

#连接池最大连接数（使用负值表示没有限制）
zk.gateway.cache.redis.jedisPool.maxactive=8
# 连接池最大阻塞等待时间（使用负值表示没有限制）
# zk.gateway.cache.redis.jedisPool.maxwait=-1 
# 连接池中的最大空闲连接
zk.gateway.cache.redis.jedisPool.maxidle=8 
# 连接池中的最小空闲连接ss
zk.gateway.cache.redis.jedisPool.minidle=0 
# 获得一个jedis实例的时候是否检查连接可用性（ping()）
#zk.test.redis.jedisPool.testonreturn=true
# idle状态监测用异步线程evict进行检查
#zk.test.redis.jedisPool.testwhileidle=true
# 一次最多evict的pool里的jedis实例个数
#zk.test.redis.jedisPool.numtestsperevictionrun=10
# test idle 线程的时间间隔
#zk.test.redis.jedisPool.timebetweenevictionrunsmillis=60000

# when_exhausted_fail = 0; 直接抛出异常throw new nosuchelementexception("pool exhausted");
# when_exhausted_block = 1;borrowobject()将会阻塞，直到有可用新的或者空闲的object为止，或者如果配置了maxwait，
# 如果请求阻塞超时，将抛出nosuchelementexception.如果maxwait为负数，请求将会无限制的阻塞下去，默认配置。
# when_exhausted_grow = 2;borrowobject()将会继续创建新的对象，并返回，因此，pool维护的对像数将超出maxactive；
#zk.test.redis.jedisPool.whenexhaustedaction=

    